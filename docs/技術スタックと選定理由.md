# 技術スタックと選定理由

<div align="center">

**Multi-Currency Household App の技術選定とその背景**

このドキュメントでは、本プロジェクトで採用した各技術の選定理由と、それらがどのように組み合わさってアプリケーション全体を構成しているかを説明します。

</div>

---

## 📋 目次

- [概要](#-概要)
- [技術スタック一覧](#-技術スタック一覧)
- [フロントエンド](#-フロントエンド)
- [バックエンド](#-バックエンド)
- [インフラ・デプロイ](#-インフラデプロイ)
- [データベース・認証](#-データベース認証)
- [外部サービス](#-外部サービス)
- [アーキテクチャ設計](#-アーキテクチャ設計)
- [技術選定の原則](#-技術選定の原則)
- [まとめ](#-まとめ)

---

## 🎯 概要

### プロジェクトの目的

1. **フルスタック開発スキルの向上**
   - フロントエンド〜バックエンド〜インフラまで一貫した設計・実装
2. **実務に即した技術選定**
   - 企業で実際に使われている技術の組み合わせ
3. **動作するプロダクト**
   - デモとして誰でもアクセス可能な完成品

### 技術選定の方針

以下の4つの基準で技術を選定しました：

| 基準 | 説明 |
|:-----|:-----|
| **🏢 業界標準** | 求人数が多く、実務で使われている技術 |
| **📚 学習容易性** | ドキュメントが充実し、トラブル時に解決策を見つけやすい |
| **💰 コスト効率** | 無料枠で運用可能、長期間デモとして公開できる |
| **⚡ 開発効率** | 短期間で高品質なアプリを完成させられる |

---

## 📊 技術スタック一覧

### 全体像

```
┌─────────────────────────────────────────────────────────┐
│                    フロントエンド                        │
│  React 18 + TypeScript + Vite + Tailwind CSS            │
│  (Vercel - Global CDN)                                  │
└────────────────┬────────────────────────────────────────┘
                 │ HTTPS / REST API
┌────────────────┴────────────────────────────────────────┐
│                   バックエンド                           │
│  Node.js 18 + Express + TypeScript                      │
│  (AWS Lambda + API Gateway - Serverless)                │
└────────────────┬────────────────────────────────────────┘
                 │ SQL Query
┌────────────────┴────────────────────────────────────────┐
│              データベース・認証                          │
│  Supabase (PostgreSQL + Row Level Security)             │
│  Supabase Auth (JWT + OAuth 2.0)                        │
└─────────────────────────────────────────────────────────┘
                 │ External API
┌────────────────┴────────────────────────────────────────┐
│                  外部サービス                            │
│  Exchangerate-API (為替レート取得)                       │
└─────────────────────────────────────────────────────────┘
```

---

## 🎨 フロントエンド

### React 18

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **業界標準** | フロントエンドフレームワークで最も求人数が多い（2024年現在） |
| **コンポーネント指向** | 再利用可能なUIコンポーネント設計の理解を示せる |
| **豊富なエコシステム** | ライブラリやツールが充実、実務でもよく使われる |
| **宣言的UI** | モダンなフロントエンド開発の考え方を体現 |
| **学習リソース** | 公式ドキュメント・コミュニティが充実 |

#### 実装のポイント

- **Hooks の活用**: `useState`, `useEffect`, `useContext` でシンプルな状態管理
- **Context API**: 認証状態や為替レート情報をグローバル管理
- **カスタムフック**: `useExchangeRates` などロジックの再利用
- **コンポーネント分割**: Atomic Design の思想を参考に階層化

---

### TypeScript

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **型安全性** | コンパイル時にバグを検出、実行時エラーを削減 |
| **保守性** | 大規模開発で必須、リファクタリングが安全 |
| **開発体験** | IDEの補完機能で生産性が大幅に向上 |
| **企業での採用率** | ほぼすべてのモダン企業がTypeScriptを採用 |
| **API契約の明確化** | フロントとバックで型定義を共有可能 |

#### 実装のポイント
```typescript
// 型定義の共有例
interface Transaction {
  id: string;
  type: 'income' | 'expense';
  amount: number;
  currency: 'JPY' | 'USD' | 'EUR';
  // ...
}

// APIレスポンスも型安全
const transactions: Transaction[] = await getTransactions(filters, token);
```

- **厳格な型チェック**: `strict: true` で最大限の型安全性
- **共通型定義**: `types/index.ts` でフロント・バック共通の型を定義
- **ジェネリクス**: APIクライアントなどで型を柔軟に扱う

---

### Vite

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **高速な開発環境** | HMR（Hot Module Replacement）が爆速 |
| **モダンなビルドツール** | esbuildベースで次世代のバンドラー |
| **シンプルな設定** | Create React Appより軽量で柔軟 |
| **業界トレンド** | 最新技術へのキャッチアップ力をアピール |
| **Vercelとの相性** | デプロイが非常にスムーズ |

#### Create React App との比較

| 項目 | Vite | Create React App |
|:-----|:-----|:-----------------|
| 起動速度 | 超高速（<1秒） | 遅い（10秒以上） |
| HMR速度 | 瞬時 | やや遅い |
| ビルド速度 | 高速 | 普通 |
| 設定の柔軟性 | 高い | 低い（eject必要） |
| トレンド | 上昇中 | 横ばい |

---

### Tailwind CSS

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **ユーティリティファースト** | CSSを書かずにスタイリング可能 |
| **開発速度** | 命名に悩まず、高速にUIを構築 |
| **一貫性** | デザインシステムが組み込まれている |
| **レスポンシブ** | モバイルファーストのブレークポイント |
| **業界採用率** | 急速に普及中のモダンなCSS手法 |

#### 実装のポイント

```tsx
<button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
  ボタン
</button>
```

- **カスタムテーマ**: `tailwind.config.js` でブランドカラーを定義
- **コンポーネント化**: よく使うスタイルはコンポーネントに抽出
- **レスポンシブ**: `sm:`, `md:`, `lg:` で画面サイズ別にスタイル適用

---

### その他フロントエンドライブラリ

| ライブラリ | 用途 | 選定理由 |
|:-----------|:-----|:---------|
| **React Router** | ルーティング | React公式推奨、クライアントサイドルーティング |
| **Axios** | HTTP通信 | シンプルなAPI、インターセプター機能 |
| **Recharts** | グラフ描画 | React専用、シンプルで美しいグラフ |
| **date-fns** | 日付操作 | 軽量、モジュラー、TypeScript対応 |
| **React Hot Toast** | 通知 | シンプルで美しいトースト通知 |

---

## ⚙️ バックエンド

### Node.js 18

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **JavaScript統一** | フロントエンドと同じ言語で開発効率向上 |
| **非同期処理** | I/O密度の高いアプリケーションに最適 |
| **豊富なパッケージ** | npmエコシステムの恩恵 |
| **求人需要** | バックエンドでも広く採用されている |
| **フルスタック** | 一貫した技術スタックをアピール |

#### 実装のポイント

- **非同期処理**: `async/await` で可読性の高い非同期コード
- **エラーハンドリング**: ミドルウェアで統一的なエラー処理
- **環境変数管理**: `.env` ファイルで設定を分離

---

### Express

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **シンプルで軽量** | 必要最小限の機能、学習コストが低い |
| **柔軟性** | 自由に設計できるため、設計力をアピール |
| **RESTful API設計** | Web APIの基礎を理解していることを示せる |
| **ミドルウェア** | 認証、ログ、エラーハンドリングの実装経験 |
| **業界標準** | Node.jsバックエンドのデファクトスタンダード |

#### 実装のポイント

```typescript
// ミドルウェアの活用例
app.use(cors());
app.use(express.json());
app.use(authMiddleware); // 認証ミドルウェア

// RESTful なルーティング
app.get('/api/transactions', getTransactions);
app.post('/api/transactions', createTransaction);
app.put('/api/transactions/:id', updateTransaction);
app.delete('/api/transactions/:id', deleteTransaction);
```

- **ルーティング**: RESTful な設計原則に従った URL 設計
- **ミドルウェア**: 横断的関心事（認証、ログ、エラー処理）を分離
- **バリデーション**: リクエストボディの検証をミドルウェアで実装

---

### TypeScript（バックエンド）

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **フロントエンドとの一貫性** | 型定義を共有できる |
| **API契約の明確化** | リクエスト・レスポンスの型定義 |
| **リファクタリングの安全性** | 大規模な変更にも対応しやすい |
| **実務での必須スキル** | エンタープライズ開発では標準 |

#### 型定義の共有例

```typescript
// types/index.ts (共通の型定義)
export interface Transaction {
  id: string;
  user_id: string;
  type: 'income' | 'expense';
  amount: number;
  currency: 'JPY' | 'USD' | 'EUR';
  // ...
}

// フロントエンド (frontend/src/services/api.ts)
import type { Transaction } from '../types';

// バックエンド (backend/src/routes/transactions.ts)
import type { Transaction } from '../types';
```

---

## 🚀 インフラ・デプロイ

### AWS Lambda

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **サーバーレスアーキテクチャ** | モダンなクラウド設計の理解 |
| **コスト効率** | 使った分だけの課金、無料枠が大きい |
| **スケーラビリティ** | 自動スケーリング、高可用性 |
| **AWS経験** | 企業が最も求めるクラウドスキル |
| **実務に直結** | 多くの企業が採用している構成 |
| **マイクロサービス** | モダンなアーキテクチャパターンの理解 |

#### 従来のサーバーとの比較

| 項目 | Lambda | EC2 |
|:-----|:-------|:----|
| コスト | 使用時のみ課金 | 常時課金 |
| スケーリング | 自動 | 手動または設定が複雑 |
| 運用負荷 | 最小限 | サーバー管理が必要 |
| 起動速度 | コールドスタートあり | 常時起動 |
| 適用範囲 | API、軽量な処理 | 何でも可能 |

#### 実装のポイント

```typescript
// Lambda ハンドラー
export const handler = serverless(app);

// コールドスタート対策
// - 依存関係を最小限に
// - 関数外でのデータベース接続プール
```

---

### API Gateway

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **Lambdaとの統合** | AWS公式のAPI管理サービス |
| **RESTful API** | 標準的なHTTPエンドポイント提供 |
| **CORS設定** | フロントエンドとの連携が容易 |
| **認証統合** | 将来的な拡張性（Cognito連携など） |
| **モニタリング** | CloudWatchとの統合でログ・メトリクス管理 |

#### 設定のポイント

- **CORS設定**: フロントエンドからのリクエストを許可
- **ステージ管理**: dev / prod 環境の分離
- **カスタムドメイン**: 独自ドメインの設定が可能

---

### Serverless Framework

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **デプロイの簡素化** | YAMLで設定、`serverless deploy`で完結 |
| **インフラのコード化** | IaC（Infrastructure as Code）の実践 |
| **ローカル開発** | `serverless-offline`でローカルテスト可能 |
| **業界標準** | サーバーレス開発のデファクトスタンダード |
| **学習コスト** | AWSコンソールより理解しやすい |

#### 設定例

```yaml
# serverless.yml
service: household-app-api

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-1
  
functions:
  api:
    handler: dist/lambda.handler
    events:
      - http:
          path: /{proxy+}
          method: ANY
          cors: true
```

---

### Vercel（フロントエンド）

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **開発効率** | Git連携で自動デプロイ、CI/CD構築 |
| **パフォーマンス** | グローバルCDN、エッジネットワーク |
| **開発者体験** | セットアップが超簡単、すぐに本番環境 |
| **プレビュー環境** | PRごとに自動生成、レビューが容易 |
| **HTTPS自動** | セキュリティがデフォルト |
| **モダンな開発フロー** | 業界標準の開発プラクティス |
| **無料枠** | ポートフォリオに最適 |

#### CI/CD フロー

```
Git Push → Vercel自動デプロイ → 本番環境に反映
         → プレビュー環境生成（PR時）
```

---

## 💾 データベース・認証

### Supabase（PostgreSQL）

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **PostgreSQL** | 業界標準のRDBMS、SQLスキルをアピール |
| **管理の容易さ** | マネージドサービスで運用負荷が低い |
| **無料枠が大きい** | 500MB DB、十分なスペック |
| **Row Level Security** | データベースレベルのセキュリティ |
| **REST API自動生成** | バックエンドとの統合が容易 |
| **開発速度** | ダッシュボードでのデータ管理が便利 |

#### PostgreSQLの強み

| 機能 | 説明 |
|:-----|:-----|
| **ACID特性** | トランザクションの信頼性が高い |
| **複雑なクエリ** | JOIN、集計など家計簿に必要な機能が充実 |
| **JSON対応** | 柔軟なデータ構造も可能 |
| **実績と信頼性** | エンタープライズでも広く採用 |
| **スキルの汎用性** | 多くの企業で使われている |

#### Row Level Security（RLS）

```sql
-- ユーザーごとにデータを分離
CREATE POLICY "Users can only see their own transactions"
ON transactions
FOR SELECT
USING (auth.uid() = user_id);
```

**RLSの利点**:
- データベースレベルでセキュリティを保証
- バックエンドのバグがあっても他ユーザーのデータは漏洩しない
- アプリケーション層の実装がシンプルになる

---

### Supabase Auth

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **セキュリティ** | 実績のある認証システム、脆弱性リスク軽減 |
| **実装速度** | 数行のコードで認証機能を実装 |
| **JWT対応** | 標準的なトークンベース認証 |
| **OAuth対応** | Google、GitHubなどのソーシャルログイン |
| **パスワード管理** | ハッシュ化、リセット機能が組み込み済み |
| **適切なツール選択** | 「車輪の再発明」を避ける判断力 |
| **RLSとの統合** | データベースとシームレスに連携 |

#### 自前実装しなかった理由

**セキュリティリスク**:
- 認証は専門性が高く、セキュリティホールを作るリスクが高い
- パスワードハッシュ化、トークン管理、セッション管理など複雑

**開発効率**:
- コア機能（複数通貨対応）に時間を割くべき
- 認証機能は差別化要因にならない

**実務的判断**:
- 企業でも既存サービス（Auth0、Cognitoなど）を活用するのが一般的
- 「適切なツールを選択する」判断力を示せる

**面接でのアピール例**:
> 「認証機能は一から実装することも検討しましたが、セキュリティの重要性を考慮し、実績のあるSupabase Authを採用しました。これは実務でも『適切なツールを選択する』という判断力を示すものです。その分、本アプリのコア機能である複数通貨対応の家計簿機能に注力し、差別化を図りました。」

---

## 🌐 外部サービス

### Exchangerate-API

#### 選定理由

| 理由 | 詳細 |
|:-----|:-----|
| **無料枠が十分** | 1,500リクエスト/月、デモには十分 |
| **シンプルなAPI** | 学習コストが低く、実装が容易 |
| **信頼性** | 安定したサービス |
| **リアルタイムレート** | 最新の為替情報を取得可能 |
| **ドキュメント充実** | 実装がスムーズ |
| **本アプリの核** | 通貨変換機能を実現するための必須要素 |

#### レート取得戦略

**キャッシュ戦略**:
```typescript
// 1日1回の更新で十分
const today = new Date().toISOString().split('T')[0];

// キャッシュチェック
const cachedRates = await supabase
  .from('exchange_rates')
  .select('*')
  .eq('date', today);

if (cachedRates.length > 0) {
  return cachedRates; // キャッシュを返す
}

// APIから取得してキャッシュ
const rates = await fetchFromAPI();
await supabase.from('exchange_rates').insert(rates);
```

**エラーハンドリング**:
```typescript
try {
  const rates = await getExchangeRates();
  return rates;
} catch (error) {
  // フォールバック: デフォルトレート
  return { USD: 1, JPY: 150, EUR: 0.92 };
}
```

---

## 🏗️ アーキテクチャ設計

### 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                         User Browser                         │
└────────────────────────────┬────────────────────────────────┘
                             │ HTTPS
                             ▼
┌─────────────────────────────────────────────────────────────┐
│               React App (Vercel - Global CDN)                │
│  - Client-side Routing (React Router)                       │
│  - State Management (Context API)                            │
│  - UI Components (Tailwind CSS)                              │
└──────────────┬──────────────────────────────┬────────────────┘
               │ REST API                     │ Auth (JWT)
               ▼                              ▼
┌──────────────────────────────┐  ┌──────────────────────────┐
│   AWS API Gateway            │  │    Supabase Auth         │
│   - CORS設定                 │  │    - JWT発行             │
│   - エンドポイント管理        │  │    - OAuth 2.0           │
└──────────────┬───────────────┘  └──────────┬───────────────┘
               │                              │
               ▼                              │
┌──────────────────────────────┐             │
│   AWS Lambda (Express API)   │             │
│   - サーバーレス実行          │             │
│   - 自動スケーリング          │             │
│   - Node.js + TypeScript     │             │
└──────────────┬───────────────┘             │
               │                              │
               ▼                              ▼
┌─────────────────────────────────────────────────────────────┐
│              Supabase (PostgreSQL + RLS)                     │
│  - transactions テーブル                                     │
│  - categories テーブル                                       │
│  - user_preferences テーブル                                 │
│  - exchange_rates テーブル                                   │
└─────────────────────────────────────────────────────────────┘
               ▲
               │ 為替レート取得（1日1回）
┌──────────────┴───────────────┐
│    Exchangerate-API          │
│    - 最新レート取得           │
│    - キャッシュで効率化       │
└──────────────────────────────┘
```

### アーキテクチャの特徴

#### 1. 関心の分離（Separation of Concerns）

```
フロントエンド  → UI/UX、状態管理
バックエンド    → ビジネスロジック、API
データベース    → データ永続化、セキュリティ
```

各層が独立しており、疎結合な設計。メンテナンス性が高い。

#### 2. スケーラビリティ

| 層 | スケーリング方法 |
|:---|:-----------------|
| **フロントエンド** | Vercel CDN - グローバル配信 |
| **バックエンド** | Lambda - 自動スケーリング |
| **データベース** | Supabase - マネージドでスケール |

#### 3. セキュリティ

```
認証層: Supabase Auth (JWT)
       ↓
API層: API Gateway + Lambda (トークン検証)
       ↓
DB層: Row Level Security (ユーザーごとにデータ分離)
```

多層防御でセキュリティを確保。

#### 4. コスト効率

すべてのサービスが無料枠で運用可能:

| サービス | 無料枠 | 実際の使用量 |
|:---------|:-------|:-------------|
| **Vercel** | 100GB帯域/月 | ~1GB/月 |
| **AWS Lambda** | 100万リクエスト/月 | ~数千/月 |
| **Supabase** | 500MB DB | ~50MB |
| **Exchangerate-API** | 1,500リクエスト/月 | ~30リクエスト/月 |

#### 5. 開発効率

```
Git Push
  ↓
Vercel自動デプロイ（フロント）
  ↓
serverless deploy（バック）
  ↓
本番環境に反映
```

CI/CDパイプラインにより、開発〜デプロイが高速。

---

### データフロー例

#### 取引登録時の処理フロー

```
1. ユーザーがフロントエンドから取引を登録
   ↓
2. Supabase Authで認証トークンを検証
   ↓
3. API GatewayがLambda（Express API）にリクエスト転送
   ↓
4. Lambda内でバリデーション実行
   ↓
5. Supabase（PostgreSQL）にデータ保存
   ↓
6. RLS（Row Level Security）でユーザー権限チェック
   ↓
7. レスポンスをフロントエンドに返却
```

#### 為替レート変換時の処理フロー

```
1. フロントエンドで通貨切り替え
   ↓
2. キャッシュされた為替レートを使用
   ↓
3. 各取引金額をクライアントサイドで変換
   ↓
4. グラフやサマリーを再計算して表示
```

**USD経由の変換ロジック**:
```
JPY 1,500円 → USD 10ドル → EUR 9.2ユーロ
（JPY/USD = 150, EUR/USD = 0.92 の場合）
```

---

## 📐 技術選定の原則

### 1. バランス重視

```
最新すぎず ←───────→ 枯れすぎず
   ↓                    ↓
学習コスト高         採用率低
ドキュメント少       最新機能なし
```

**採用技術**:
- React 18（最新だが安定版）
- Node.js 18（LTS版）
- PostgreSQL（枯れた技術）

### 2. 完成度優先

```
確実に動くもの > 最新技術の詰め込み
```

**実践例**:
- 認証は自前実装せず Supabase Auth
- グラフは複雑なD3.jsではなくRechartsで簡単に
- デプロイはVercel/Lambdaで確実に

### 3. アピールポイントの最大化

```
技術スタックで示せるスキル:
┌─────────────────────────────┐
│ ✅ フロントエンド開発        │
│ ✅ バックエンド開発          │
│ ✅ データベース設計          │
│ ✅ クラウドインフラ（AWS）   │
│ ✅ サーバーレス              │
│ ✅ CI/CD                     │
│ ✅ TypeScript                │
│ ✅ REST API設計              │
└─────────────────────────────┘
```

### 4. コスト意識

```
無料で運用 → 長期間デモ公開 → 就活期間中ずっと見せられる
```

**重要性**:
- コスト意識も技術選定の重要な要素

---

## 🎯 まとめ

### この技術スタックの強み

#### ✅ 実務に直結する経験が積める

- サーバーレスアーキテクチャ
- RESTful API設計
- JWT認証
- CI/CDパイプライン

#### ✅ 完成度の高いアプリが作れる

- 確実に動く技術の組み合わせ
- 豊富なドキュメント・コミュニティ
- トラブルシューティングが容易

#### ✅ 無料で運用できる

- すべて無料枠内で運用
- 長期間デモとして公開可能
- ランニングコストゼロ
---

[⬆ Back to Top](#技術スタックと選定理由)

</div>